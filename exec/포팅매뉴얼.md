# Deploy with Docker

## Docker 설치하기

- 설치 환경: Ubuntu 20 이상, Windows 10 이상
- APT를 활용한 설치 방법 - [Docker 공식 사이트를 참조](https://docs.docker.com/engine/install/ubuntu/)
    
    ```bash
    # apt 업데이트
    sudo apt-get update
    # https 이외의 통신으로 apt 패키지를 받을 수 있도록 하는 패키지 설치
    sudo apt-get install ca-certificates curl gnupg
    
    # Docker GPG Key 받기
    sudo install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    sudo chmod a+r /etc/apt/keyrings/docker.gpg
    
    # APT Repository 업데이트
    echo \
      "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # 한 번 더 apt 업데이트
    sudo apt-get update
    
    # Docker 설치
    sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    ```
    
- 직접 설치하는 방법
    - 이 방법은 Docker 공식 문서가 알려주지 않는 OS에 대한 설치 혹은 apt 설치에 문제가 발생한 사람들을 위한 방법
        - 패키지 수동 설치: [https://download.docker.com/linux/](https://download.docker.com/linux/) 이동
        - 원하는 OS 항목으로 이동 (ex: Debian 등)
        - [`https://download.docker.com/linux/[Target OS]/dists/[Target version]/pool/stable/`](https://download.docker.com/linux/debian/dists/bullseye/pool/stable/) 까지.
        - 다음 목록에서 Docker에 설치하고자 하는 컴퓨터의 CPU architecture 따라 선택 (ex: arm64)
        - 해당 목록에서 `docker-ce` `docker-ce-cli` `containerd.io` `docker-buildx-plugin` 으로 시작하는 목록들을 확인 → 각각 버전이 상이하므로 최대한 버전을 잘 맞추어 선택
        - 버전을 선택했다면 해당 항목의 링크를 복사 → 리눅스에서 `wget [docker package link]`  명령어 실행 → 패키지 다운로드
        - `[패키지 이름].deb` 파일을 받았으면 `docker-ce` `docker-ce-cli` `containerd.io` `docker-buildx-plugin` 이 순서대로 `sudo dpkg --install [패키지 이름].deb` 명령어 실행
        - 설치 끝
- Windows에서 설치하는 방법
    - Docker Hub 프로그램을 설치하면 powershell에 Docker 자동 설치

## 배포하기

- 배포 전 준비
    - 빌드할 프로젝트 디렉토리 구조
        - `project/device/front`
        - `project/device/back`
        - `project/remote/front`
        - `project/remote/back`
    - `*/front` 디렉토리는 react app 이므로 `npm install` 이후 `npm run build` 수행
    - `*/back` 디렉토리는 express를 사용하기 때문에 `npm install` 만 수행
    - `npm` 명령어가 지원되지 않음 → node.js 설치 (node18 적극 권장)
- 간단한 Docker build
    - Dockerfile
        
        ```docker
        # 이 컨테이너에서 사용할 프로그램 선언 및 설치
        FROM nginx
        
        # 컨테이너 기동 시 아래 경로 파일에서부터 시작
        WORKDIR /app
        
        # /app/build 디렉토리 생성
        RUN mkdir ./build
        
        # 작업중인 프로젝트에서 Dockerfile이 존재하는 경로상 
        # ./build 디렉토리 내용을 전부 컨테이너의 /app/build 로 이동
        ADD ./build ./build
        
        # 컨테이너에 설치한 nginx의 설정 파일 삭제
        RUN rm /etc/nginx/conf.d/default.conf
        
        # 마찬가지로 nignx의 기본 설정 파일 삭제
        RUN rm /etc/nginx/nginx.conf
        
        # 삭제한 파일에 대해 프로젝트에서 작성한 nginx 설정 파일로 대체하기 위해 복사
        COPY ./default.conf /etc/nginx/conf.d/
        
        # 마찬가지로 복사
        COPY ./nginx.conf /etc/nginx/
        
        # 이 컨테이너가 개방할 네트워크 포트 번호
        EXPOSE 80 443
        
        # 모든 준비가 끝났으면 아래 명령어를 차례대로 수행
        CMD ["nginx", "-g", "daemon off;"]
        ```
        
        - docker image build하기 위한 명령어 파일
        - image로 만들고자 할 build 파일이 존재하는 프로젝트 파일 내에서 작성한다.
            
            (ex: `project/device/frontend/Dockerfile`, `project/device/backend/Dockerfile`, `project/remote/frontend/Dockerfile`, `project/remote/backend/Dockerfile`)
            
- build를 할 때에는 `docker build -t [사용자 정의 Tag]` 명령어를 실행한다.
    - Tag는 `[사용자 계정]/[Hub에 생성한 프로젝트]:[Image Tag 이름]` 와 같이 이름을 정할 수 있다.
    - build 이전에 react으로 작성된 `device/frontend` 와 `remote/backend` 는 `npm install` 명령어와 `npm run  build` 명령어를 통해 nginx로 배포 가능한 상태로 미리 `build` 디렉토리를 생성해야 한다.
    - node express로 작성된 `device/backend` 및 `remote/backend` 는 바로 build하면 된다.
    - 주의사항:  `device/frontend` 및 `device/backend` 파트는 raspberry pi에서 실행된다. 즉, arm64 아키텍처를 따르기 때문에 `docker build --platform linux/arm64/v8 -t [태그명] .` 명령어로 build를 수행한다.
- build image는 docker hub에 올린 뒤, linux 환경에서 다시 내려받는다. (Docker Hub 계정 login 필요)
    - hub로 올리기 : `docker push gugaro/kkumta:front-server-0.1`
    - hub에서 받기 : `docker pull gugaro/kkumta:front-server-0.1`
- image를 받았다면 컨테이너에 올려 실행한다.
    - 우리 프로젝트는 총 4개의 image 컨테이너를 사용하고, 각각 raspberry 및 aws에 탑재한다.
    - for raspberry
        
        ```bash
        docker run -d --name front-app \
        							--restart=always \
        							--network=host \
        			 gugaro/kkumta:front-server-for-raspberry-0.1
        ```
        
        ```bash
        docker run -d --name back-server \
        							--restart=always \
        							--network=host
        			 gugaro/kkumta:back-server-for-raspberry-0.1
        ```
        
        - 실행할 컨테이너의 이름은 `--name` 옵션으로 정할 수 있다.
        - `--restart=always` 옵션은 호스트 서버 등이 가동될 때 컨테이너도 자동으로 가동시키라는 뜻이다.
        - 두 컨테이너는 상호 http 통신으로 접근하기 때문에 독립된 컨테이너 네트워크에 의존할 경우 접근성이 매우 떨어지게 된다.
        - 따라서 `--network=host` 옵션을 통해 호스트 서버, 즉 raspberry pi의 네트워크와 통합하는 작업이 필요하다. → 이를 통해 [localhost](http://localhost) 주소가 각각의 컨테이너 주소를 가리키지 않게 할 수 있다.
    - for aws
        
        ```bash
        docker run -d --name front-web-app \
        							--network=host \
        							--volume /etc/letsencrypt:/etc/letsencrypt \
        							--volume /var/www/letsencrypt:/var/www/letsencrypt \
        			 gugaro/kkumta:front-server-0.1
        ```
        
        ```bash
        docker run -d --name back-web-server \
        							--network=host \
        						  --volume /etc/letsencrypt:/etc/letsencrypt \
        						  --volume /var/www/letsencrypt:/var/www/letsencrypt \
        			 gugaro/kkumta:back-server-0.1
        ```
        
        - aws에서도 front side와 back side가 상호 통신을 하기 때문에 호스트 네트워크와 통일시킨다.
        - 추가로 두 컨테이너에 포함된 `--volume ~` 옵션은, https로 동작시키기 위해 certbot에서 발급받은 ssl 키 파일을 각각의 컨테이너에 [마운트] 시키는 옵션이다. 이는 곧 컨테이너가 따로 파일을 생성하지 않되 호스트 서버가 갖고 있는 파일을 그대로 이용하겠다는 의미이다.
        - Ubuntu 20에서 Nginx로 배포하는 서버에 대한 ssl key 발급받는 방법 : [https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal](https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal)
- 배포를 마쳤다면 접속해보자.
    - 접속 주소는 `https://[배포한 서버 주소]`
    - 만약 Backend의 REST API를 확인해 보고 싶다면 `https://[배포한 서버 주소]:8090`
- 알면 좋은 기능들
    - 컨테이너 상태 확인: `docker ps -a`
    - 컨테이너 시작, 중단, 재시작, 삭제: `docker start/stop/restart/rm [컨테이너 이름]`
    - 가동 중인 컨테이너의 로그 확인: `docker logs [컨테이너 이름]`
    - 해당 컨테이너의 터미널 실행: `docker exec -it [컨테이너 이름] /bin/bash`
